{"meta":{"title":"alpha's blog","subtitle":"","description":"","author":"alpha","url":"http://alphayan.cn","root":"/"},"pages":[{"title":"about","date":"2020-12-19T12:48:48.000Z","updated":"2020-12-20T12:41:53.505Z","comments":false,"path":"about/index.html","permalink":"http://alphayan.cn/about/index.html","excerpt":"","text":"一名游戏开发人员, 爱折腾些小东西!"},{"title":"","date":"2020-12-19T13:43:17.574Z","updated":"2020-12-19T13:43:17.574Z","comments":false,"path":"tags/index.html","permalink":"http://alphayan.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-12-19T13:43:32.981Z","updated":"2020-12-19T13:43:32.981Z","comments":false,"path":"categories/index.html","permalink":"http://alphayan.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Cocos Creator 多语言组件","slug":"Cocos-Creator-Localized","date":"2020-11-23T14:18:18.000Z","updated":"2020-12-20T14:04:19.315Z","comments":true,"path":"2020/11/23/Cocos-Creator-Localized/","link":"","permalink":"http://alphayan.cn/2020/11/23/Cocos-Creator-Localized/","excerpt":"","text":"Cocos Creator 优雅的多语言组件实现 Cocos Creator 优雅的多语言组件实现 简介 怎么跑起来 目录结构 实现方式 简介基于 cocos creator 2.4.3 的一个手游项目模板, 提供一些自定义组件以及 Demo, 不定期维护中, 欢迎点赞收藏…感兴趣一起交流的可以加我的微信: yanjfia2013, 备注 creator 项目地址: https://github.com/yanjifa/game-template 本次着重介绍多语言组件, Demo在线查看目前的多语言组件如果想对已经上线的项目进行多语言支持, 普遍都要我对每个 Label 组件都操作一遍, 挂上组件脚本, 这波操作说实话, 小项目还好, 大项目简直让人崩溃。所以之前基于 1.10.3 版本搞了一个使用上更方便的多语言实现, 现在适配到 2.4.3 版本, 并添加了对 BMFONT 的支持。 继承 cc.Label 内置组件实现, 使用上完全兼容 cc.Label。 老项目方便接入, vscode 全局查找替换即可。123456// cocos creator 开发者工具, 控制台输入// uuid 为 LocalizedLabel.ts 脚本的 uuidEditor.Utils.UuidUtils.compressUuid(&quot;712432e0-72b6-4e45-90c5-42bf111e8964&quot;)// 得到压缩后的 uuid, 全局替换 prefab &amp; fire 文件中的 cc.Label&quot;71243LgcrZORZDFQr8RHolk&quot;// 重新打开 prefab, 组件就以替换完毕 废话不多说, 该上图了。 replaceComp6fc9757e6e57132a.png 支持编辑器预览 LocalizedLabel0d9ef91a0f42be2a.gif 修改语言设置立即生效 setting907adb52785a093c.gif 怎么跑起来克隆完项目后初始化并更新子模块, 子模块使用了论坛 Next 大佬的 ccc-detools 我比较喜欢这个工具, 堪称神器。 12&#x2F;&#x2F; 不更新无法使用浏览器预览git submodule update --init --recursive 安装依赖, 项目根目录执行 12&#x2F;&#x2F; 必须npm install 全局安装 ESlint 1234&#x2F;&#x2F; 非必须npm install -g eslint typescript @typescript-eslint&#x2F;parser @typescript-eslint&#x2F;eslint-plugin&#x2F;&#x2F; nvm 可能还需指定需要 NODE 环境变量export NODE_PATH&#x3D;$HOME&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v12.19.0&#x2F;lib&#x2F;node_modules &#x2F;&#x2F; 根据自己使用的版本 什么是 ESlint ? ESLint 是一个开源的 JavaScript 代码检查工具，由 Nicholas C. Zakas 于2013年6月创建。代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。 JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。 ESLint 的初衷是为了让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插入的。ESLint 的默认规则与其他的插件并没有什么区别，规则本身和测试可以依赖于同样的模式。为了便于人们使用，ESLint 内置了一些规则，当然，你可以在使用过程中自定义规则。 ESLint 使用 Node.js 编写，这样既可以有一个快速的运行环境的同时也便于安装。 为什么不是 TSlint ? :warning: TSLint已于2019年弃用. Please see this issue for more details: Roadmap: TSLint → ESLint. now typescript-eslint is your best option for linting TypeScript. 在我看来使用 ESlint 的意义 统一代码风格, 项目组内不同人员写出风格基本一致的代码。 提高代码可读性。 这是此项目使用到的规则: 展开查看 .eslintrc.json &#123; \"env\": &#123; \"browser\": true, \"node\": true &#125;, \"globals\": &#123; \"Editor\": true, \"Vue\": true &#125;, \"extends\": [ \"eslint:recommended\" ], \"parserOptions\": &#123; \"ecmaVersion\": 12, \"sourceType\": \"module\" &#125;, \"rules\": &#123; // 尤达表达式 \"yoda\": \"warn\", // parseInt \"radix\": \"error\", // 禁止多个连续空格 \"no-multi-spaces\": [ \"error\", &#123; \"ignoreEOLComments\": true, \"exceptions\": &#123; \"Property\": true, \"VariableDeclarator\": true &#125; &#125; ], // 箭头表达式空格 \"arrow-spacing\": [ \"error\", &#123; \"before\": true, \"after\": true &#125; ], // 使用 === or !=== \"eqeqeq\": \"error\", // for in 循环必须包含 if 语句 \"guard-for-in\": \"error\", // 双引号 \"quotes\": [ \"error\", \"double\" ], // 行尾空格警告 \"no-trailing-spaces\": \"warn\", // 一行最大字符 \"max-len\": [ \"warn\", &#123; \"code\": 160 &#125; ], // 未定义 \"no-unused-vars\": \"warn\", \"no-undef\": \"error\", // 分号 \"semi\": [ \"error\", \"always\", &#123; \"omitLastInOneLineBlock\": true &#125; ], // 禁止分号前后空格 \"semi-spacing\": \"error\", // 禁止不必要的分号 \"no-extra-semi\": \"error\", // 注释相关 \"comma-spacing\": [ \"warn\", &#123; \"before\": false, \"after\": true &#125; ], \"comma-dangle\": [ \"error\", \"always-multiline\" ], \"no-multiple-empty-lines\": [ \"error\", &#123; \"max\": 2, \"maxEOF\": 1, \"maxBOF\": 1 &#125; ], \"line-comment-position\": [ \"warn\", &#123; \"position\": \"above\" &#125; ], \"spaced-comment\": [ \"error\", \"always\", &#123; \"line\": &#123; \"markers\": [\"/\"], \"exceptions\": [\"-\", \"+\"] &#125;, \"block\": &#123; \"markers\": [\"!\"], \"exceptions\": [\"*\"], \"balanced\": true &#125; &#125; ] &#125;, // typescript 独有规则 \"overrides\": [ &#123; \"files\": [ \"*.ts\" ], \"plugins\": [ \"@typescript-eslint\" ], \"parser\": \"@typescript-eslint/parser\", \"extends\": [ \"plugin:@typescript-eslint/recommended\" ], \"rules\": &#123; \"@typescript-eslint/no-duplicate-imports\": \"error\", \"@typescript-eslint/ban-ts-comment\": \"off\", // 4 空格缩进 \"@typescript-eslint/indent\": [ \"warn\", 4 ], \"@typescript-eslint/explicit-module-boundary-types\": \"off\", \"@typescript-eslint/no-unused-vars\": \"off\", \"@typescript-eslint/space-before-function-paren\": [ \"error\", &#123; \"anonymous\": \"never\", \"named\": \"never\", \"asyncArrow\": \"always\" &#125; ], \"@typescript-eslint/naming-convention\": [ \"warn\", &#123; \"selector\": \"typeParameter\", \"format\": [ \"PascalCase\" ], \"prefix\": [\"T\"] &#125;, &#123; \"selector\": \"variable\", \"format\": [ \"camelCase\", \"UPPER_CASE\" ] &#125;, &#123; \"selector\": \"interface\", \"format\": [ \"PascalCase\" ], \"custom\": &#123; \"regex\": \"^I[A-Z]\", \"match\": true &#125; &#125; ] &#125; &#125;, &#123; \"files\": [ \"assets/scripts/Enum.ts\" ], \"rules\": &#123; \"line-comment-position\": [ \"warn\", &#123; \"position\": \"beside\" &#125; ] &#125; &#125; ] &#125; 目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081.├── README.md├── assets│ ├── resources│ │ ├── language &#x2F;&#x2F; 多语言根目录│ │ │ ├── en &#x2F;&#x2F; 英文│ │ │ │ ├── ArialUnicodeMs.fnt│ │ │ │ ├── ArialUnicodeMs.png│ │ │ │ └── StringConfig.json &#x2F;&#x2F; 字符串配置表导出配置│ │ │ └── zh &#x2F;&#x2F; 中文│ │ │ ├── ArialUnicodeMs.fnt│ │ │ ├── ArialUnicodeMs.png│ │ │ └── StringConfig.json│ │ ├── listview│ │ │ └── prefab│ │ │ ├── ListViewDemo.prefab│ │ │ └── ListViewDemoItem.prefab│ │ └── setting│ │ └── prefab│ │ └── Setting.prefab│ ├── scene│ │ └── Main.fire│ ├── scripts│ │ ├── Enum.ts│ │ ├── Game.ts│ │ ├── Macro.ts│ │ ├── Main.ts│ │ ├── base│ │ │ ├── BasePopView.ts &#x2F;&#x2F; 弹窗基类│ │ │ ├── BaseScene.ts &#x2F;&#x2F; 场景基类│ │ │ └── BaseSingeton.ts &#x2F;&#x2F; 单例基类│ │ ├── component &#x2F;&#x2F; 组件│ │ │ ├── ListView.ts &#x2F;&#x2F; 支持复用, 和滚动条的 ListView 组件│ │ │ ├── LocalizedLabel.ts &#x2F;&#x2F; 多语言 label 组件│ │ │ └── LocalizedRichText.ts &#x2F;&#x2F; 多语言 RichText 组件│ │ ├── manager│ │ │ ├── AssetManager.ts &#x2F;&#x2F; 资源管理器│ │ │ ├── AudioManager.ts &#x2F;&#x2F; 音频管理器(未实现)│ │ │ ├── PopViewManager.ts &#x2F;&#x2F; 弹窗管理器│ │ │ └── SceneManager.ts &#x2F;&#x2F; 场景管理器│ │ ├── scene│ │ │ └── Home.ts│ │ ├── util│ │ │ ├── GameUtil.ts &#x2F;&#x2F; 待实现│ │ │ ├── LocalizedUtil.ts &#x2F;&#x2F; 多语言工具, 负责加载语言目录的资源, 获取对应 Id 文本│ │ │ ├── NotifyUtil.ts &#x2F;&#x2F; 全局事件工具│ │ │ └── StorageUtil.ts &#x2F;&#x2F; 存档工具, 相比 cc.sys.localStorage 多了一层缓存机制│ │ └── view│ │ ├── listviewdemo│ │ │ ├── ListViewDemo.ts│ │ │ └── ListViewDemoItem.ts│ │ └── setting│ │ └── Setting.ts│ └── shader│ ├── effects│ │ └── avatar-mask.effect│ └── materials│ └── avatar-mask.mtl├── creator.d.ts├── game.d.ts &#x2F;&#x2F; 为扩展的组件提供定义文件, 防止编辑器报错├── package-lock.json├── package.json├── packages│ └── game-helper &#x2F;&#x2F; 项目插件│ ├── component &#x2F;&#x2F; 插件提供的组件模板│ │ └── prefab│ │ ├── ListView.prefab│ │ ├── LocalizedLabel.prefab│ │ └── LocalizedRichText.prefab│ ├── i18n│ │ ├── en.js│ │ └── zh.js│ ├── inspectors &#x2F;&#x2F; 组件都是继承 creator 原生组件, 通过扩展 inspector 实现│ │ ├── listview.js│ │ ├── localizedlabel.js│ │ └── localizedrichtext.js│ ├── main.js &#x2F;&#x2F; 编辑器模式下获取多语言文本方法│ ├── package.json &#x2F;&#x2F; 里面设置了, 编辑器模式下, 返回的语言 zh || en│ └── panel│ └── index.js├── project.json 实现方式 组件脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import &#123; ENotifyType &#125; from &quot;../Enum&quot;;import Game from &quot;../Game&quot;;const &#123;ccclass, property, executeInEditMode, menu, inspector&#125; = cc._decorator;@ccclass@executeInEditMode()@menu(`$&#123;CC_EDITOR &amp;&amp; Editor.T(&quot;game-helper.projectcomponent&quot;)&#125;/LocalizedLabel`)@inspector(&quot;packages://game-helper/inspectors/localizedlabel.js&quot;)export default class LocalizedLabel extends cc.Label &#123; @property() private _tid = &quot;&quot;; @property(&#123; multiline: true, tooltip: &quot;多语言 text id&quot;, &#125;) set tid(value: string) &#123; this._tid = value; this.updateString(); &#125; get tid() &#123; return this._tid; &#125; @property() private _bmfontUrl = &quot;&quot;; @property(&#123; tooltip: &quot;动态加载 bmfonturl&quot;, &#125;) set bmfontUrl(value: string) &#123; this._bmfontUrl = value; this.updateString(); &#125; get bmfontUrl() &#123; return this._bmfontUrl; &#125; protected onLoad() &#123; super.onLoad(); Game.NotifyUtil.on(ENotifyType.LANGUAGE_CHANGED, this.onLanguageChanged, this); this.updateString(); &#125; protected onDestroy() &#123; Game.NotifyUtil.off(ENotifyType.LANGUAGE_CHANGED, this.onLanguageChanged, this); super.onDestroy(); &#125; /** * 收到语言变更通知 * * @private * @memberof LocalizedLabel */ private onLanguageChanged() &#123; this.updateString(); &#125; /** * 更新文本 * * @private * @returns &#123;*&#125; * @memberof LocalizedLabel */ private updateString(): void &#123; if (!this._tid) &#123; return; &#125; if (CC_EDITOR) &#123; // 编辑器模式下, 从插件中获取文本 Editor.Ipc.sendToMain(&quot;game-helper:getLangStr&quot;, this._tid, (e: Error, str: string) =&gt; &#123; if (e) &#123; return; &#125; this.string = &quot;&quot; + str; &#125;); &#125; else &#123; // 获取多语言文本 this.string = &quot;&quot; + Game.LocalizeUtil.getLangStr(this._tid); // 如果使用了 bmfont, 切换对应语言的 bmfont // _bmfontUrl 为自动生成 if (this._bmfontUrl) &#123; const lang = Game.LocalizeUtil.language; this.font = cc.resources.get&lt;cc.BitmapFont&gt;(this._bmfontUrl.replace(&quot;$&#123;lang&#125;&quot;, lang), cc.BitmapFont); &#125; &#125; &#125;&#125; 插件脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&quot;use strict&quot;;const ipcMain = require(&quot;electron&quot;).ipcMain;const fs = require(&quot;fs&quot;);module.exports = &#123; localizeCfgs: null, load() &#123; ipcMain.on(&quot;editor:ready&quot;, this.onEditorReady.bind(this)); // this.profiles.load(); this.loadLangConfig(); &#125;, unload() &#123; // execute when package unloaded &#125;, onEditorReady() &#123; // &#125;, // 加载多语言文本配置, 和项目中使用的是相同的 loadLangConfig() &#123; const configPath = this.profiles.get(&quot;path&quot;); const lang = this.profiles.get(&quot;lang&quot;); const fileName = this.profiles.get(&quot;fileName&quot;); try &#123; this.localizeCfgs = JSON.parse(fs.readFileSync(`$&#123;Editor.Project.path&#125;/$&#123;configPath&#125;/$&#123;lang&#125;/$&#123;fileName&#125;`, &quot;utf-8&quot;)); Editor.success(&quot;localized config load success:&quot;, lang); &#125; catch (e) &#123; Editor.warn(&quot;localized config load fail:&quot;, e); &#125; &#125;, messages: &#123; open() &#123; Editor.Panel.open(&quot;game-helper&quot;); &#125;, // reload lang config reload() &#123; this.loadLangConfig(); &#125;, // 获取多语言配置字符串 getLangStr(event, param) &#123; if (this.localizeCfgs === null) &#123; event.reply(new Error(&quot;config not load&quot;), null); &#125; const [tid, ...args] = param.split(&quot;,&quot;); let str = this.localizeCfgs[tid]; if (str) &#123; args.forEach((arg, index) =&gt; &#123; str = str.replace(&quot;$&#123;p&quot; + (index + 1) + &quot;&#125;&quot;, arg); &#125;); event.reply(null, str); &#125; else &#123; event.reply(null, tid); &#125; &#125;, &#125;, profiles: &#123; config: null, path: &quot;&quot;, load() &#123; this.path = Editor.url(&quot;packages://game-helper/package.json&quot;); this.config = JSON.parse(fs.readFileSync(this.path, &quot;utf8&quot;)); &#125;, get(key) &#123; return this.config.profiles.local[key]; &#125;, &#125;,&#125;; 更多的东西就不展开讲了, 感兴趣的 clone 下来看看吧。","categories":[],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://alphayan.cn/tags/cocos/"}]},{"title":"Cocos Creator 扩展内置组件","slug":"Cocos-Creator-Component-Extension","date":"2020-04-08T03:35:19.000Z","updated":"2020-12-20T14:04:15.927Z","comments":true,"path":"2020/04/08/Cocos-Creator-Component-Extension/","link":"","permalink":"http://alphayan.cn/2020/04/08/Cocos-Creator-Component-Extension/","excerpt":"","text":"Cocos Creator 扩展内置组件 起因 扩展 Button 组件 扩展属性检查器 扩展脚本代码 替换内置组件 起因 项目中很多按钮是拟物设计, 按下时, 子节点不能跟随移动, 看上去很怪。第一个想到的就是把需要处理的按钮单独再挂一个脚本，后来为什么没这么做， 因为懒，一个一个按钮找，太难了，这时候想到了扩展 cc.Button 组件, 以前也尝试过，但是没有成功，这次借此机会。 适用于 creator 3.0 之前的版本 扩展 Button 组件扩展属性检查器 说干就干, 名字我都想好了就叫 ‘CustomButton’, 继承自 ‘cc.Button’。 123456const &#123;ccclass, property&#125; = cc._decorator;@ccclassexport default class CustomButton extends cc.Button &#123;&#125; 但是这属性检查器里面所有属性都显示出来了，第一次尝试就是因为这原因放弃了，显然哪里出了问题, 查阅文档，说是要扩展 Inspector，文档还行，不过要是能提供一份内置的 Inspector 就更好了, 不然无从改起啊, 论坛里搜了下, 果然有办法, 在编辑器里选中你要扩展的组件，然后打开 Creator 开发者工具，Sources-&gt;inspector 找到你要的组件, 复制出来就可以了。 按照官方文档，新建一个插件 ‘custom-component’ 放到项目目录下。在插件根目录新建一个文件夹 ‘button’ 放 inspector.js ,照着葫芦画瓢修改一下, 增加自己组件需要的属性: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&quot;use strict&quot;;Vue.component(&quot;cc-button&quot;, &#123; template: ` &lt;ui-prop v-prop=&quot;target.target&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;div class=&quot;horizontal layout end-justified&quot; style=&quot;padding:5px 0;margin-bottom:5px;&quot;&gt; &lt;ui-button class=&quot;blue tiny&quot; @confirm=&quot;resetNodeSize&quot; v-disabled=&quot;_checkResizeToTarget(target.target, multi)&quot; &gt; Resize to Target &lt;/ui-button&gt; &lt;/div&gt; &lt;ui-prop v-prop=&quot;target.interactable&quot; :multi-values=&quot;multi&quot; &gt; // 扩展触发音效支持 &lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.audioClip&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; // 扩展按下时支持子节点位置变化 &lt;div v-if=&quot;_checkTransition(target.transition, 2, multi)&quot;&gt; &lt;ui-prop name=&quot;childOffest&quot; type=&quot;cc.Vec2&quot; step=&quot;1&quot; :multi-values=&quot;multi&quot; v-value=&quot;target.childOffest.value&quot; v-values=&quot;target.childOffest.values&quot; v-readonly=&quot;target.childOffest.readonly&quot; tooltip=$&#123;Editor.T(&quot;custom-component.childOffset&quot;)&#125; &gt;&lt;/ui-prop&gt; &lt;/div&gt; &lt;ui-prop v-prop=&quot;target.enableAutoGrayEffect&quot; v-show=&quot;_autoGrayEffectEnabled()&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop v-prop=&quot;target.transition&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;div v-if=&quot;_checkTransition(target.transition, 1, multi)&quot;&gt; &lt;ui-prop indent=1 v-prop=&quot;target.normalColor&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.pressedColor&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.hoverColor&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.disabledColor&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.duration&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;/div&gt; &lt;div v-if=&quot;_checkTransition(target.transition, 2, multi)&quot;&gt; &lt;ui-prop indent=1 v-prop=&quot;target.normalSprite&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.pressedSprite&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.hoverSprite&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.disabledSprite&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;/div&gt; &lt;div v-if=&quot;_checkTransition(target.transition, 3, multi)&quot;&gt; &lt;ui-prop indent=1 v-prop=&quot;target.duration&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;ui-prop indent=1 v-prop=&quot;target.zoomScale&quot; :multi-values=&quot;multi&quot; &gt;&lt;/ui-prop&gt; &lt;/div&gt; &lt;cc-array-prop :target.sync=&quot;target.clickEvents&quot;&gt;&lt;/cc-array-prop&gt; `, props: &#123; target: &#123; twoWay: !0, type: Object &#125;, multi: &#123; type: Boolean &#125;, &#125;, methods: &#123; T: Editor.T, resetNodeSize() &#123; const t = &#123; id: this.target.uuid.value, path: &quot;_resizeToTarget&quot;, type: &quot;Boolean&quot;, isSubProp: !1, value: !0 &#125;; Editor.Ipc.sendToPanel(&quot;scene&quot;, &quot;scene:set-property&quot;, t); &#125;, _autoGrayEffectEnabled() &#123; return !(1 === this.target.transition.value || 2 === this.target.transition.value &amp;&amp; this.target.disabledSprite.value.uuid); &#125;, _checkResizeToTarget: (t, n) =&gt; !!n || !t.value.uuid, _checkTransition: (t, n, i) =&gt; i ? t.values.every(t =&gt; t === n) : t.value === n, &#125;,&#125;); 扩展脚本代码 TS脚本代码需要做如下操作, 引入 inspector.js 文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import GameUtil from &quot;../../util/GameUtil&quot;;const &#123;ccclass, property, inspector, executeInEditMode, menu, help&#125; = cc._decorator;@ccclass@executeInEditMode@menu(&quot;i18n:MAIN_MENU.component.ui/Button&quot;)@help(&quot;i18n:COMPONENT.help_url.button&quot;)@inspector(&quot;packages://custom-component/button/inspector.js&quot;)export default class CustomButton extends cc.Button &#123; @property(&#123; type: cc.AudioClip, displayName: &quot;Audio&quot;, tooltip: CC_DEV &amp;&amp; &quot;按钮触发时播放的音频剪辑&quot;, &#125;) private audioClip: cc.AudioClip = null; @property(cc.Vec2) private childOffest: cc.Vec2 = cc.v2(0, 0); private btnPressed: boolean = false; private btnRect: cc.Rect = null; // 这里注意注册和移除监听事件不要放到 onLoad 和 onDestory 里 // 会导致现已经不显示的按钮, 拦截触摸事件, 导致层级低的按钮, 交互出现异常 protected onEnable() &#123; this.node.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this); this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.onTouchCancel, this); this.node.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this); this.node.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this); super.onEnable(); &#125; protected onDisable() &#123; this.node.off(cc.Node.EventType.TOUCH_START, this.onTouchStart, this); this.node.off(cc.Node.EventType.TOUCH_CANCEL, this.onTouchCancel, this); this.node.off(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this); this.node.off(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this); super.onDisable(); &#125; private onTouchStart(event: cc.Event.EventTouch) &#123; if (!this.interactable || !this.enabledInHierarchy) &#123; return; &#125; this.btnPressed = true; this.addOffset(); &#125; private onTouchCancel(event: cc.Event.EventTouch) &#123; if (!this.interactable || !this.enabledInHierarchy) &#123; return; &#125; if (this.btnPressed) &#123; this.subOffset(); &#125; this.btnPressed = false; &#125; private onTouchMove(event: cc.Event.EventTouch) &#123; if (!this.interactable || !this.enabledInHierarchy) &#123; return; &#125; this.btnRect = this.node.getBoundingBox(); let pressed = true; const nodeVec = this.node.parent.convertToNodeSpaceAR(event.getLocation()); if (!this.btnRect.contains(nodeVec)) &#123; pressed = false; &#125; if (this.btnPressed &amp;&amp; !pressed) &#123; this.subOffset(); &#125; if (!this.btnPressed &amp;&amp; pressed) &#123; this.addOffset(); &#125; this.btnPressed = pressed; &#125; private onTouchEnd(event: cc.Event.EventTouch) &#123; if (!this.interactable || !this.enabledInHierarchy) &#123; return; &#125; if (this.btnPressed) &#123; this.audioClip &amp;&amp; GameUtil.getInstance().playEffect(this.audioClip); this.subOffset(); &#125; this.btnPressed = false; &#125; private addOffset() &#123; if (this.transition !== cc.Button.Transition.SPRITE) &#123; return; &#125; if (this.childOffest.equals(cc.Vec2.ZERO)) &#123; return; &#125; for (const child of this.node.children) &#123; child.position = child.position.add(this.childOffest); &#125; &#125; private subOffset() &#123; if (this.transition !== cc.Button.Transition.SPRITE) &#123; return; &#125; if (this.childOffest.equals(cc.Vec2.ZERO)) &#123; return; &#125; for (const child of this.node.children) &#123; child.position = child.position.sub(this.childOffest); &#125; &#125;&#125; 这样按钮支持设置按下时子节点移动多少距离，基本能满足目前的要求了, 同时支持了按钮触发音效，做成 prefab 拖到 creator 自定义组件里，再也不用担心按钮没有触发音效了。 替换内置组件 组件扩展好了，但是要怎么替换原来已经在使用的 cc.Button 组件呢?有个小技巧。在脚本上右键显示资源 UUID 和路径的到如下输出:151434b23-493e-46dc-a064-9d5ce8a7f692 (51Q0sjST5G3KBknVzop&#x2F;aS), db:&#x2F;&#x2F;assets&#x2F;script&#x2F;view&#x2F;common&#x2F;CustomButton.ts 括号里面有个不知道干嘛的 ID, 用 UUID 的前 5 个字符替换括号内前 4 个字符得到一个串 ‘51434sjST5G3KBknVzop/aS’, 用这个串替换项目 fire 和 prefab 中所有的 cc.Button, 如下图 之后重启项目，项目中所有的 Button 组件就都替换为自定义的Button组件了, 对比下效果: button","categories":[],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://alphayan.cn/tags/cocos/"}]},{"title":"高效的 Cocos Creator 裁圆角头像 shader","slug":"Cocos-Creator-Avatar-Shader","date":"2019-10-22T14:18:18.000Z","updated":"2020-12-20T14:04:12.455Z","comments":true,"path":"2019/10/22/Cocos-Creator-Avatar-Shader/","link":"","permalink":"http://alphayan.cn/2019/10/22/Cocos-Creator-Avatar-Shader/","excerpt":"","text":"论坛链接 先上效果图 shader.gif #2.1.2 &amp; 2.2.0 demo https://github.com/yanjifa/shaderDemo.git #1.10 及以下片元着色器代码 12345678910111213141516171819202122#ifdef GL_ESprecision mediump float;#endifvarying vec4 v_fragmentColor;varying vec2 v_texCoord;uniform float u_edge;void main()&#123; float edge &#x3D; u_edge; vec4 color &#x3D; texture2D(CC_Texture0, v_texCoord); vec2 uv &#x3D; v_texCoord - vec2(0.5, 0.5); float rx &#x3D; abs(uv.x) - (0.5 - edge); float ry &#x3D; abs(uv.y) - (0.5 - edge); float mx &#x3D; step(0.5 - edge, abs(uv.x)); float my &#x3D; step(0.5 - edge, abs(uv.y)); float radius &#x3D; length(vec2(rx, ry)); float a &#x3D; 1.0 - mx * my * step(edge, radius) * smoothstep(0., edge * 0.02, radius - edge); gl_FragColor &#x3D; vec4(color.rgb, color.a * a);&#125; 上个2.1.2 下的性能对比，满屏 176 个头像, 在 chrome 下测试#使用 mask mask.jpg 共 880 drawcall， 一个 头像 5 个 drawcall, Renderer 5.07 ms #使用材质 material.jpg 可以合批只有一个 drawcall， Renderer 0.34 ms 这是在pc 上进行的测试， 手机上差距可能更大一些，使用材质还是有优势的， 更重要的是材质支持圆角","categories":[],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://alphayan.cn/tags/cocos/"}]}],"categories":[],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://alphayan.cn/tags/cocos/"}]}